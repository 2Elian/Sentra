"""
Community detector for graph clustering.

This module implements community detection algorithms (Leiden, Louvain)
for GraphRAG hierarchical clustering.
"""

import networkx as nx
from typing import List, Dict, Any
from sentra.core.models import Entity, Relation, Community
from sentra.utils.logger import logger

try:
    import igraph as ig
    import leidenalg
    IGRAPH_AVAILABLE = True
except ImportError:
    IGRAPH_AVAILABLE = False
    logger.warning("igraph and/or leidenalg not available. Community detection will use NetworkX.")


class CommunityDetector:
    """
    Detects communities in the knowledge graph.

    This class implements graph clustering algorithms to identify
    communities (clusters) of densely connected entities.
    """

    def __init__(self, algorithm: str = "leiden", resolution: float = 1.0):
        """
        Initialize community detector.

        Args:
            algorithm: Clustering algorithm ("leiden", "louvain", "label_propagation")
            resolution: Resolution parameter for Leiden/Louvain (higher = fewer, larger communities)
        """
        self.algorithm = algorithm.lower()
        self.resolution = resolution

        if self.algorithm == "leiden" and not IGRAPH_AVAILABLE:
            logger.warning("Leiden algorithm requested but igraph/leidenalg not available. Falling back to label_propagation.")
            self.algorithm = "label_propagation"

    async def detect_communities(
        self,
        entities: List[Entity],
        relations: List[Relation]
    ) -> List[Community]:
        """
        Detect communities in the graph.

        Args:
            entities: List of entities (nodes)
            relations: List of relations (edges)

        Returns:
            List of detected communities
        """
        if self.algorithm == "leiden":
            return await self._detect_leiden(entities, relations)
        elif self.algorithm == "louvain":
            return await self._detect_louvain(entities, relations)
        else:
            return await self._detect_label_propagation(entities, relations)

    async def _detect_leiden(
        self,
        entities: List[Entity],
        relations: List[Relation]
    ) -> List[Community]:
        """
        Detect communities using Leiden algorithm.

        Args:
            entities: List of entities
            relations: List of relations

        Returns:
            List of communities
        """
        if not IGRAPH_AVAILABLE:
            return await self._detect_label_propagation(entities, relations)

        # Create entity ID mapping
        entity_id_map = {entity.id: idx for idx, entity in enumerate(entities)}

        # Build igraph
        edges = []
        weights = []
        for relation in relations:
            if relation.source in entity_id_map and relation.target in entity_id_map:
                edges.append((entity_id_map[relation.source], entity_id_map[relation.target]))
                weights.append(relation.weight)

        # Create graph
        g = ig.Graph(len(entities), edges)
        g.es["weight"] = weights

        # Run Leiden algorithm
        partition = leidenalg.find_partition(
            g,
            leidenalg.ModularityVertexPartition,
            resolution_parameter=self.resolution,
            weights="weight"
        )

        # Build communities
        communities = []
        for community_id, member_indices in enumerate(partition):
            entity_ids = [entities[idx].id for idx in member_indices]

            # Collect source chunks
            source_chunks = set()
            for idx in member_indices:
                source_chunks.update(entities[idx].source_chunk_ids)

            communities.append(Community(
                community_id=f"C_{community_id}",
                level=0,
                title=f"Community {community_id}",
                summary="",  # Will be generated by CommunitySummarizer
                entity_ids=entity_ids,
                source_chunk_ids=list(source_chunks),
                metadata={
                    "size": len(entity_ids),
                    "algorithm": "leiden"
                }
            ))

        logger.info(f"Detected {len(communities)} communities using Leiden algorithm")
        return communities

    async def _detect_louvain(
        self,
        entities: List[Entity],
        relations: List[Relation]
    ) -> List[Community]:
        """
        Detect communities using Louvain algorithm (via NetworkX).

        Args:
            entities: List of entities
            relations: List of relations

        Returns:
            List of communities
        """
        # Build NetworkX graph
        G = nx.Graph()
        G.add_nodes_from([entity.id for entity in entities])

        for relation in relations:
            G.add_edge(
                relation.source,
                relation.target,
                weight=relation.weight
            )

        # Detect communities
        from networkx.algorithms.community import greedy_modularity_communities
        communities_list = greedy_modularity_communities(G, weight='weight')

        # Build communities
        communities = []
        for community_id, member_ids in enumerate(communities_list):
            entity_ids = list(member_ids)

            # Collect source chunks
            source_chunks = set()
            for entity in entities:
                if entity.id in entity_ids:
                    source_chunks.update(entity.source_chunk_ids)

            communities.append(Community(
                community_id=f"C_{community_id}",
                level=0,
                title=f"Community {community_id}",
                summary="",  # Will be generated by CommunitySummarizer
                entity_ids=entity_ids,
                source_chunk_ids=list(source_chunks),
                metadata={
                    "size": len(entity_ids),
                    "algorithm": "louvain"
                }
            ))

        logger.info(f"Detected {len(communities)} communities using Louvain algorithm")
        return communities

    async def _detect_label_propagation(
        self,
        entities: List[Entity],
        relations: List[Relation]
    ) -> List[Community]:
        """
        Detect communities using label propagation (via NetworkX).

        Args:
            entities: List of entities
            relations: List of relations

        Returns:
            List of communities
        """
        # Build NetworkX graph
        G = nx.Graph()
        G.add_nodes_from([entity.id for entity in entities])

        for relation in relations:
            G.add_edge(
                relation.source,
                relation.target,
                weight=relation.weight
            )

        # Detect communities
        from networkx.algorithms.community import label_propagation_communities
        communities_list = label_propagation_communities(G)

        # Build communities
        communities = []
        for community_id, member_ids in enumerate(communities_list):
            entity_ids = list(member_ids)

            # Collect source chunks
            source_chunks = set()
            for entity in entities:
                if entity.id in entity_ids:
                    source_chunks.update(entity.source_chunk_ids)

            communities.append(Community(
                community_id=f"C_{community_id}",
                level=0,
                title=f"Community {community_id}",
                summary="",  # Will be generated by CommunitySummarizer
                entity_ids=entity_ids,
                source_chunk_ids=list(source_chunks),
                metadata={
                    "size": len(entity_ids),
                    "algorithm": "label_propagation"
                }
            ))

        logger.info(f"Detected {len(communities)} communities using Label Propagation")
        return communities
