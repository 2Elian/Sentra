# 前端开发-知识库管理功能模块

现在需要对前端的知识库管理功能模块进行开发。
首先需要去除掉文档管理，因为这个可以嵌入到知识库管理里面。

## 1. 点击到知识库管理功能页面的展示

我希望能够展示当前用户所属的知识库，查询当前用户的知识库列表接口如下：

```java
    /**
     * 获取用户的知识库列表
     */
    @GetMapping("/owner/{ownerUserId}")
    public Result<List<KnowledgeBaseResponse>> listByOwner(@PathVariable("ownerUserId") String ownerUserId,
                                                            @RequestHeader("X-Tenant-Id") String tenantId) {
        List<KnowledgeBaseResponse> list = kbService.listByOwner(tenantId, ownerUserId);
        return Result.success(list);
    }

# 接口返回值是
{
    "code": 200,
    "message": "操作成功",
    "data": [
        {
            "id": "2016213455065985026",
            "kbId": "0451765337b5ea53",
            "name": "通用知识库测试1",
            "ownerUserId": "elian",
            "scope": "PUBLIC",
            "description": "这是一个通用的测试知识库1",
            "tenantId": "2016187266498756608",
            "createdAt": "2026-01-28T02:15:21.766193",
            "updatedAt": "2026-01-28T02:15:21.766193"
        }
    ]
}
```

你首先要把这个展示到前端

但是你要注意：如果是普通用户，就走v1/kb/owner/{ownerUserId}这个接口查询。如果是管理员，那么需要走下面的接口(会查询到租户下的所有知识库)

```java
    /**
     * 获取租户下的所有知识库
     */
    @GetMapping("/list")
    public Result<List<KnowledgeBaseResponse>> listByTenant(@RequestHeader("X-Tenant-Id") String tenantId) {
        List<KnowledgeBaseResponse> list = kbService.listByTenantId(tenantId);
        return Result.success(list);
    }

# 接口返回值是
{
    "code": 200,
    "message": "操作成功",
    "data": [
        {
            "id": "2016213455065985026",
            "kbId": "0451765337b5ea53",
            "name": "通用知识库测试1",
            "ownerUserId": "elian",
            "scope": "PUBLIC",
            "description": "这是一个通用的测试知识库1",
            "tenantId": "2016187266498756608",
            "createdAt": "2026-01-28T02:15:21.766193",
            "updatedAt": "2026-01-28T02:15:21.766193"
        }
    ]
}
```

## 2. 对于知识库的增删改查

做好知识库隔离之后，可以有一些对知识库的增删改查功能，具体接口定义如下：

```java

    /**
     * 创建知识库
     */
    @PostMapping
    public Result<KnowledgeBaseResponse> create(@RequestBody @Valid KnowledgeBaseCreateRequest request,
                                                 @RequestHeader("X-Tenant-Id") String tenantId) {
        KnowledgeBaseResponse response = kbService.createKnowledgeBase(request, tenantId);
        return Result.success(response);
    }

    /**
     * 更新知识库
     */
    @PutMapping("/{kbId}")
    public Result<Boolean> update(@PathVariable("kbId") String kbId,
                                  @RequestBody @Valid KnowledgeBaseUpdateRequest request) {
        boolean updated = kbService.updateKnowledgeBase(kbId, request);
        return Result.success(updated);
    }

    /**
     * 删除知识库
     */
    @DeleteMapping("/{kbId}")
    public Result<Boolean> delete(@PathVariable("kbId") String kbId) {
        boolean deleted = kbService.deleteKnowledgeBase(kbId);
        return Result.success(deleted);
    }

    /**
     * 获取知识库详情
     */
    @GetMapping("/{kbId}")
    public Result<KnowledgeBaseResponse> get(@PathVariable("kbId") String kbId) {
        KnowledgeBaseResponse response = kbService.getKnowledgeBaseByKbId(kbId);
        return Result.success(response);
    }
```

## 3. 具体知识库里面的文档管理

点击进具体知识库里面，能够看到这个知识库里面的所有文档，具体接口在v1/document. 也是可以增删改查：

```java
@RestController
    @RequestMapping("/v1/document")
@RequiredArgsConstructor
public class DocumentController {

    private final IDocumentService documentService;

    /**
     * 上传文档到知识库
     *
     * @param kbId 知识库ID
     * @param entityTemplateId 实体类型模板ID（可选，不传则使用知识库的默认模板）
     * @param file 文档文件
     * @return 上传的文档信息
     */
    @PostMapping("/upload")
    public Result<Document> upload(@RequestParam("kbId") String kbId,
                                   @RequestParam(value = "entityTemplateId", required = false) String entityTemplateId,
                                   @RequestParam("file") MultipartFile file) {
        Document document = documentService.upload(kbId, entityTemplateId, file);
        return Result.success(document);
    }

    /**
     * 获取知识库下的文档列表
     */
    @GetMapping("/list")
    public Result<List<Document>> listByKbId(@RequestParam("kbId") String kbId) {
        LambdaQueryWrapper<Document> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Document::getKbId, kbId)
                .orderByDesc(Document::getCreatedAt);
        List<Document> list = documentService.list(queryWrapper);
        return Result.success(list);
    }

    /**
     * 获取文档详情
     */
    @GetMapping("/{documentId}")
    public Result<Document> get(@PathVariable("documentId") String documentId) {
        Document document = documentService.getById(documentId);
        if (document == null) {
            return Result.error("文档不存在");
        }
        return Result.success(document);
    }

    /**
     * 删除文档
     * 会同时删除：SFTP文件、OCR结果、Python知识库数据、本地图谱、Neo4j节点、MongoDB内容
     */
    @DeleteMapping("/{documentId}")
    public Result<Boolean> delete(@PathVariable("documentId") String documentId) {
        boolean deleted = documentService.deleteDocument(documentId);
        return Result.success(deleted);
    }
}


```

要注意：upload接口具体实现如下(会进行知识库解析：走的是RabbitMQ)
```java
  @Override
    @Transactional(rollbackFor = Exception.class)
    public Document upload(String kbId, String entityTemplateId, MultipartFile file) {
        // 校验知识库是否存在
        KnowledgeBase kb = kbService.lambdaQuery()
                .eq(KnowledgeBase::getKbId, kbId)
                .one();
        if (kb == null) {
            throw new BusinessException("知识库不存在");
        }

        // 校验实体类型模板（如果提供了）
        if (entityTemplateId != null && !entityTemplateId.isEmpty()) {
            // TODO: 校验模板是否存在以及是否属于当前租户 --> 首先需要更改实体表和实体描述表 增加租户ID字段 才能进行校验 这里先log一下
            log.info("文档指定使用实体类型模板: {}", entityTemplateId);
        } else {
            log.info("文档未指定实体类型模板，将使用系统默认模板");
        }

        // 校验文件格式（v0.0.1只支持PDF）
        // TODO 这里需要有一个文件类型的判断 pdf走ocr一套的pipeline txt、excel之类的可能要单独处理
        String originalFilename = file.getOriginalFilename();
        if (originalFilename == null || !originalFilename.toLowerCase().endsWith(".pdf")) {
            throw new BusinessException("仅支持PDF格式的文件");
        }

        // 生成远程文件路径
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMddHHmmss"));
        String fileExtension = originalFilename.substring(originalFilename.lastIndexOf("."));
        String remoteFileName = kbId + "_" + timestamp + "_" + UUID.randomUUID().toString().substring(0, 8) + fileExtension;
        String remoteFilePath = storageProperties.getSftp().getUploadPath() + "/" + remoteFileName;

        // 上传文件到SFTP服务器
        try (InputStream inputStream = file.getInputStream()) {
            boolean uploaded = sftpUtil.uploadFile(inputStream, remoteFilePath);
            if (!uploaded) {
                throw new BusinessException("文件上传失败");
            }
        } catch (Exception e) {
            log.error("文件上传失败: {}", remoteFilePath, e);
            throw new BusinessException("文件上传失败: " + e.getMessage());
        }
        // 创建documentid
        String documentId = KbIdGenerator.generate(kb.getTenantId(), kb.getOwnerUserId(), originalFilename);

        // 创建文档记录
        Document document = new Document();
        document.setKbId(kbId);
        document.setFilename(originalFilename);
        document.setFileSize(file.getSize());
        document.setFileType(fileExtension);
        document.setRemoteFilePath(remoteFilePath);
        document.setStatus(DocumentStatus.UPLOADED);
        document.setProgress(0);
        document.setTenantId(kb.getTenantId());
        document.setCreatedAt(LocalDateTime.now());
        document.setUpdatedAt(LocalDateTime.now());
        document.setDocumentUniqueId(documentId);
        document.setEntityTemplateId(entityTemplateId); // 保存实体类型模板ID

        // 保存到数据库
        boolean saved = this.save(document);
        if (!saved) {
            throw new BusinessException("文档记录保存失败");
        }

        log.info("文档上传成功，documentId: {}, kbId: {}, filename: {}, entityTemplateId: {}",
                document.getId(), kbId, originalFilename, entityTemplateId);

        // 发送OCR解析任务到RabbitMQ
        sendOcrTask(document, kb);

        return document;
```
创建好知识库后，产物有：在本地端的一个.graphml文件、本地端的一些qa数据、还有很多的其他数据，但是没通过接口返回。我不知道这里要具体怎么与前端进行配合，你可以告诉我，然后我们一起探讨。

